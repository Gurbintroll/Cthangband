using System;
using System.Collections.Generic;
using System.Drawing;
using Cthangband.Enumerations;
using Cthangband.StaticData;
using Cthangband.UI;

namespace Cthangband
{
    [Serializable]
    internal class Level
    {
        private const string ImageMonsterHack = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
        private const string ImageObjectHack = "?/|\\\"!$()_-=[]{},~";
        private const int MapHgt = MaxHgt / Ratio;
        private const int MapWid = MaxWid / Ratio;
        public const int MaxHgt = 66;
        public const int MaxWid = 198;
        private const int Ratio = 3;
        private readonly int[] _lightX = new int[Constants.LightMax];
        private readonly int[] _lightY = new int[Constants.LightMax];
        private readonly Player _player;

        private readonly int[][] _priorityTable =
        {
            new[] {FeatureType.FeatNone, 2}, new[] {FeatureType.FeatFloor, 5}, new[] {FeatureType.FeatSecret, 10},
            new[] {FeatureType.FeatQuartzNoTreas, 11}, new[] {FeatureType.FeatMagmaNoTreas, 12}, new[] {FeatureType.FeatRubble, 13},
            new[] {FeatureType.FeatOpen, 15}, new[] {FeatureType.FeatBroken, 15},
            new[] {FeatureType.FeatLockedDoor0 + 0x00, 17}, new[] {FeatureType.FeatQuartzVisTreas, 19},
            new[] {FeatureType.FeatMagmaVisTreas, 19}, new[] {FeatureType.FeatLess, 25}, new[] {FeatureType.FeatMore, 25},
            new[] {0, 0}
        };

        private readonly int[] _viewX = new int[Constants.ViewMax];
        private readonly int[] _viewY = new int[Constants.ViewMax];
        public readonly int[] Ddd = {2, 8, 6, 4, 3, 1, 9, 7, 5};
        public readonly int[] Ddx = {0, -1, 0, 1, -1, 0, 1, -1, 0, 1};
        public readonly int[] DdxDdd = {0, 0, 1, -1, 1, -1, 1, -1, 0};
        public readonly int[] Ddy = {0, 1, 1, 1, 0, 0, 0, -1, -1, -1};
        public readonly int[] DdyDdd = {1, -1, 0, 0, 1, 1, -1, -1, 0};
        public readonly GridTile[][] Grid = new GridTile[MaxHgt][];
        public readonly Item[] Items = new Item[Constants.MaxOIdx];
        public readonly MonsterList Monsters;
        public readonly int[] TempX = new int[Constants.TempMax];
        public readonly int[] TempY = new int[Constants.TempMax];
        private int _flowHead;
        private int _flowN;
        private int _flowTail;
        private int _lightN;
        private int _viewN;
        public int CurHgt;
        public int CurWid;
        public int Feeling;
        public bool GoodItemFlag;
        public int MaxPanelCols;
        public int MaxPanelRows;
        public int MCnt;
        public int MMax = 1;
        public int MonsterLevel;
        public int ObjectLevel;
        public int OCnt;
        public int OMax = 1;
        public bool OpeningChest;
        public int PanelCol;
        public int PanelColMax;
        public int PanelColMin;
        public int PanelColPrt;
        public int PanelRow;
        public int PanelRowMax;
        public int PanelRowMin;
        public int PanelRowPrt;
        public int Rating;
        public int TempN;

        public Level()
        {
            // Get a local reference to the player for efficiency
            _player = SaveGame.Instance.Player;
            for (var i = 0; i < MaxHgt; i++)
            {
                Grid[i] = new GridTile[MaxWid];
                for (var j = 0; j < MaxWid; j++)
                {
                    Grid[i][j] = new GridTile();
                }
            }
            for (var j = 0; j < Constants.MaxOIdx; j++)
            {
                Items[j] = new Item();
            }
            Monsters = new MonsterList(this);
        }

        public void Acquirement(int y1, int x1, int num, bool great)
        {
            while (num-- != 0)
            {
                var qPtr = new Item();
                if (!qPtr.MakeObject(true, great))
                {
                    continue;
                }
                DropNear(qPtr, -1, y1, x1);
            }
        }

        public bool GridOpenNoItem(int y, int x)
        {
            return Grid[y][x].FeatureType.IsOpenFloor && Grid[y][x].Item == 0;
        }

        public bool GridPassableNoCreature(int y, int x)
        {
            return GridPassable(y, x) && Grid[y][x].Monster == 0 && !(y == _player.Py && x == _player.Px);
        }

        public bool GridPassable(int y, int x)
        {
            return (Grid[y][x].FeatureType.IsPassable);
        }

        private bool GridBlocksLos(int y, int x)
        {
            return Grid[y][x].FeatureType.BlocksLos;
        }

        private void CaveLightHack(int y, int x)
        {
            Grid[y][x].TileFlags.Set(GridTile.PlayerLit);
            _lightY[_lightN] = y;
            _lightX[_lightN] = x;
            _lightN++;
        }

        public bool GridOpenNoItemOrCreature(int y, int x)
        {
            return Grid[y][x].FeatureType.IsOpenFloor && Grid[y][x].Item == 0 && Grid[y][x].Monster == 0 &&
                   !(y == _player.Py && x == _player.Px);
        }

        public void CaveSetFeat(int y, int x, string feat)
        {
            var cPtr = Grid[y][x];
            cPtr.FeatureType = StaticResources.Instance.FloorTileTypes[feat];
            NoteSpot(y, x);
            LightSpot(y, x);
        }

        public void CaveSetBackground(int y, int x, string feat)
        {
            var cPtr = Grid[y][x];
            cPtr.BackgroundFeature = StaticResources.Instance.FloorTileTypes[feat];
        }

        public void CaveRemoveFeat(int y, int x)
        {
            var cPtr = Grid[y][x];
            cPtr.RevertToBackground();
            NoteSpot(y, x);
            LightSpot(y, x);
        }

        public bool CaveValidBold(int y, int x)
        {
            var cPtr = Grid[y][x];
            int nextOIdx;
            if (cPtr.FeatureType.IsPermanent)
            {
                return false;
            }
            for (var thisOIdx = cPtr.Item; thisOIdx != 0; thisOIdx = nextOIdx)
            {
                var oPtr = Items[thisOIdx];
                nextOIdx = oPtr.NextInStack;
                if (string.IsNullOrEmpty(oPtr.RandartName) == false || oPtr.IsFixedArtifact())
                {
                    return false;
                }
            }
            return true;
        }

        private void CaveViewHack(GridTile c, int y, int x)
        {
            c.TileFlags.Set(GridTile.IsVisible);
            _viewY[_viewN] = y;
            _viewX[_viewN] = x;
            _viewN++;
        }

        public int ChestCheck(int y, int x)
        {
            var cPtr = Grid[y][x];
            int nextOIdx;
            for (var thisOIdx = cPtr.Item; thisOIdx != 0; thisOIdx = nextOIdx)
            {
                var oPtr = Items[thisOIdx];
                nextOIdx = oPtr.NextInStack;
                if (oPtr.Category == ItemCategory.Chest)
                {
                    return thisOIdx;
                }
            }
            return 0;
        }

        public void CompactObjects(int size)
        {
            int i;
            int num, cnt;
            if (size != 0)
            {
                Profile.Instance.MsgPrint("Compacting objects...");
                SaveGame.Instance.Player.Redraw |= RedrawFlag.PrMap;
            }
            for (num = 0, cnt = 1; num < size; cnt++)
            {
                var curLev = 5 * cnt;
                var curDis = 5 * (20 - cnt);
                for (i = 1; i < OMax; i++)
                {
                    var oPtr = Items[i];
                    var kPtr = oPtr.ItemType;
                    if (oPtr.ItemType == null)
                    {
                        continue;
                    }
                    if (kPtr.Level > curLev)
                    {
                        continue;
                    }
                    int y;
                    int x;
                    if (oPtr.HoldingMonsterIndex != 0)
                    {
                        var mPtr = Monsters[oPtr.HoldingMonsterIndex];
                        y = mPtr.Fy;
                        x = mPtr.Fx;
                        if (Program.Rng.RandomLessThan(100) < 90)
                        {
                            continue;
                        }
                    }
                    else
                    {
                        y = oPtr.Y;
                        x = oPtr.X;
                    }
                    if (curDis > 0 && Distance(SaveGame.Instance.Player.Py, SaveGame.Instance.Player.Px, y, x) < curDis)
                    {
                        continue;
                    }
                    var chance = 90;
                    if ((oPtr.IsFixedArtifact() || string.IsNullOrEmpty(oPtr.RandartName) == false) && cnt < 1000)
                    {
                        chance = 100;
                    }
                    if (Program.Rng.RandomLessThan(100) < chance)
                    {
                        continue;
                    }
                    DeleteObjectIdx(i);
                    num++;
                }
            }
            for (i = OMax - 1; i >= 1; i--)
            {
                var oPtr = Items[i];
                if (oPtr.ItemType != null)
                {
                    continue;
                }
                CompactObjectsAux(OMax - 1, i);
                OMax--;
            }
        }

        private void CompactObjectsAux(int i1, int i2)
        {
            Item oPtr;
            if (i1 == i2)
            {
                return;
            }
            for (var i = 1; i < OMax; i++)
            {
                oPtr = Items[i];
                if (oPtr.ItemType == null)
                {
                    continue;
                }
                if (oPtr.NextInStack == i1)
                {
                    oPtr.NextInStack = i2;
                }
            }
            oPtr = Items[i1];
            if (oPtr.HoldingMonsterIndex != 0)
            {
                var mPtr = Monsters[oPtr.HoldingMonsterIndex];
                if (mPtr.HoldOIdx == i1)
                {
                    mPtr.HoldOIdx = i2;
                }
            }
            else
            {
                var y = oPtr.Y;
                var x = oPtr.X;
                var cPtr = Grid[y][x];
                if (cPtr.Item == i1)
                {
                    cPtr.Item = i2;
                }
            }
            Items[i2] = Items[i1];
            Items[i1] = new Item();
        }

        public void DeleteMonster(int y, int x)
        {
            if (!InBounds(y, x))
            {
                return;
            }
            var cPtr = Grid[y][x];
            if (cPtr.Monster != 0)
            {
                Monsters.DeleteMonsterIdx(cPtr.Monster, true);
            }
        }

        public void DeleteObject(int y, int x)
        {
            int nextOIdx;
            if (!InBounds(y, x))
            {
                return;
            }
            var cPtr = Grid[y][x];
            for (var thisOIdx = cPtr.Item; thisOIdx != 0; thisOIdx = nextOIdx)
            {
                var oPtr = Items[thisOIdx];
                nextOIdx = oPtr.NextInStack;
                Items[thisOIdx] = new Item();
                OCnt--;
            }
            cPtr.Item = 0;
            LightSpot(y, x);
        }

        public void DeleteObjectIdx(int oIdx)
        {
            ExciseObjectIdx(oIdx);
            var jPtr = Items[oIdx];
            if (jPtr.HoldingMonsterIndex == 0)
            {
                var y = jPtr.Y;
                var x = jPtr.X;
                LightSpot(y, x);
            }
            Items[oIdx] = new Item();
            OCnt--;
        }

        public void DisplayMap(out int cy, out int cx)
        {
            int x, y, maxy;
            int ta;
            char tc;
            var ma = new int[MapHgt + 2][];
            for (var i = 0; i < MapHgt + 2; i++)
            {
                ma[i] = new int[MapWid + 2];
            }
            var mc = new char[MapHgt + 2][];
            for (var i = 0; i < MapHgt + 2; i++)
            {
                mc[i] = new char[MapWid + 2];
            }
            var mp = new int[MapHgt + 2][];
            for (var i = 0; i < MapHgt + 2; i++)
            {
                mp[i] = new int[MapWid + 2];
            }
            for (y = 0; y < MapHgt + 2; ++y)
            {
                for (x = 0; x < MapWid + 2; ++x)
                {
                    ma[y][x] = Colour.White;
                    mc[y][x] = ' ';
                    mp[y][x] = 0;
                }
            }
            var maxx = maxy = 0;
            for (var i = 0; i < CurWid; ++i)
            {
                for (var j = 0; j < CurHgt; ++j)
                {
                    x = i / Ratio + 1;
                    y = j / Ratio + 1;
                    if (x > maxx)
                    {
                        maxx = x;
                    }
                    if (y > maxy)
                    {
                        maxy = y;
                    }
                    MapInfo(j, i, out ta, out tc);
                    var tp = Priority(ta, tc);
                    if (mp[y][x] < tp)
                    {
                        mc[y][x] = tc;
                        ma[y][x] = ta;
                        mp[y][x] = tp;
                    }
                }
            }
            x = maxx + 1;
            y = maxy + 1;
            var xOffset = (80 - x) / 2;
            var yOffset = (24 - y) / 2;
            mc[0][0] = mc[0][x] = mc[y][0] = mc[y][x] = '+';
            for (x = 1; x <= maxx; x++)
            {
                mc[0][x] = mc[maxy + 1][x] = '-';
            }
            for (y = 1; y <= maxy; y++)
            {
                mc[y][0] = mc[y][maxx + 1] = '|';
            }
            for (y = 0; y < maxy + 2; ++y)
            {
                Gui.Goto(yOffset + y, xOffset);
                for (x = 0; x < maxx + 2; ++x)
                {
                    ta = ma[y][x];
                    tc = mc[y][x];
                    if (_player.Invuln != 0)
                    {
                        ta = Colour.White;
                    }
                    else if (_player.WraithForm != 0)
                    {
                        ta = Colour.Black;
                    }
                    Gui.Print(ta, tc);
                }
            }
            cy = yOffset + _player.Py / Ratio + 1;
            cx = xOffset + _player.Px / Ratio + 1;
        }

        public int Distance(int y1, int x1, int y2, int x2)
        {
            var dy = y1 > y2 ? y1 - y2 : y2 - y1;
            var dx = x1 > x2 ? x1 - x2 : x2 - x1;
            var d = dy > dx ? dy + (dx >> 1) : dx + (dy >> 1);
            return d;
        }

        public void DropNear(Item jPtr, int chance, int y, int x)
        {
            int ty, tx;
            int thisOIdx, nextOIdx;
            GridTile cPtr;
            var flag = false;
            var done = false;
            var plural = jPtr.Count != 1;
            var oName = jPtr.Description(false, 0);
            if (!(string.IsNullOrEmpty(jPtr.RandartName) == false || jPtr.IsFixedArtifact()) &&
                Program.Rng.RandomLessThan(100) < chance)
            {
                var p = plural ? "" : "s";
                Profile.Instance.MsgPrint($"The {oName} disappear{p}.");
                if (SaveGame.Instance.Player.WizardMode)
                {
                    Profile.Instance.MsgPrint("(breakage)");
                }
                return;
            }
            var bs = -1;
            var bn = 0;
            var by = y;
            var bx = x;
            for (var dy = -3; dy <= 3; dy++)
            {
                for (var dx = -3; dx <= 3; dx++)
                {
                    var comb = false;
                    var d = dy * dy + dx * dx;
                    if (d > 10)
                    {
                        continue;
                    }
                    ty = y + dy;
                    tx = x + dx;
                    if (!InBounds(ty, tx))
                    {
                        continue;
                    }
                    if (!Los(y, x, ty, tx))
                    {
                        continue;
                    }
                    cPtr = Grid[ty][tx];
                    if (cPtr.FeatureType.IsOpenFloor == false)
                    {
                        continue;
                    }
                    var k = 0;
                    for (thisOIdx = cPtr.Item; thisOIdx != 0; thisOIdx = nextOIdx)
                    {
                        var oPtr = Items[thisOIdx];
                        nextOIdx = oPtr.NextInStack;
                        if (oPtr.CanAbsorb(jPtr))
                        {
                            comb = true;
                        }
                        k++;
                    }
                    if (!comb)
                    {
                        k++;
                    }
                    if (k > 99)
                    {
                        continue;
                    }
                    var s = 1000 - (d + k * 5);
                    if (s < bs)
                    {
                        continue;
                    }
                    if (s > bs)
                    {
                        bn = 0;
                    }
                    if (++bn >= 2 && Program.Rng.RandomLessThan(bn) != 0)
                    {
                        continue;
                    }
                    bs = s;
                    by = ty;
                    bx = tx;
                    flag = true;
                }
            }
            if (!flag && !(jPtr.IsFixedArtifact() || string.IsNullOrEmpty(jPtr.RandartName) == false))
            {
                var p = plural ? "" : "s";
                Profile.Instance.MsgPrint($"The {oName} disappear{p}.");
                if (SaveGame.Instance.Player.WizardMode)
                {
                    Profile.Instance.MsgPrint("(no floor space)");
                }
                return;
            }
            for (var i = 0; !flag; i++)
            {
                if (i < 1000)
                {
                    ty = Program.Rng.RandomSpread(by, 1);
                    tx = Program.Rng.RandomSpread(bx, 1);
                }
                else
                {
                    ty = Program.Rng.RandomLessThan(CurHgt);
                    tx = Program.Rng.RandomLessThan(CurWid);
                }
                cPtr = Grid[ty][tx];
                if (cPtr.FeatureType.IsOpenFloor == false)
                {
                    continue;
                }
                by = ty;
                bx = tx;
                if (!GridOpenNoItem(by, bx))
                {
                    continue;
                }
                flag = true;
            }
            cPtr = Grid[by][bx];
            for (thisOIdx = cPtr.Item; thisOIdx != 0; thisOIdx = nextOIdx)
            {
                var oPtr = Items[thisOIdx];
                nextOIdx = oPtr.NextInStack;
                if (oPtr.CanAbsorb(jPtr))
                {
                    oPtr.Absorb(jPtr);
                    done = true;
                    break;
                }
            }
            var oIdx = OPop();
            if (!done && oIdx == 0)
            {
                var p = plural ? "" : "s";
                Profile.Instance.MsgPrint($"The {oName} disappear{p}.");
                if (SaveGame.Instance.Player.WizardMode)
                {
                    Profile.Instance.MsgPrint("(too many objects)");
                }
                if (jPtr.FixedArtifactIndex != 0)
                {
                    Profile.Instance.FixedArtifacts[jPtr.FixedArtifactIndex].CurNum = 0;
                }
                return;
            }
            if (!done)
            {
                Items[oIdx] = new Item(jPtr);
                jPtr = Items[oIdx];
                jPtr.Y = by;
                jPtr.X = bx;
                jPtr.HoldingMonsterIndex = 0;
                jPtr.NextInStack = cPtr.Item;
                cPtr.Item = oIdx;
            }
            NoteSpot(by, bx);
            LightSpot(by, bx);
            Gui.PlaySound(Sound.SoundDrop);
            if (chance != 0 && by == SaveGame.Instance.Player.Py && bx == SaveGame.Instance.Player.Px)
            {
                Profile.Instance.MsgPrint("You feel something roll beneath your feet.");
            }
        }

        public void ExciseObjectIdx(int oIdx)
        {
            int thisOIdx, nextOIdx;
            var prevOIdx = 0;
            var jPtr = Items[oIdx];
            if (jPtr.HoldingMonsterIndex != 0)
            {
                var mPtr = Monsters[jPtr.HoldingMonsterIndex];
                for (thisOIdx = mPtr.HoldOIdx; thisOIdx != 0; thisOIdx = nextOIdx)
                {
                    var oPtr = Items[thisOIdx];
                    nextOIdx = oPtr.NextInStack;
                    if (thisOIdx == oIdx)
                    {
                        if (prevOIdx == 0)
                        {
                            mPtr.HoldOIdx = nextOIdx;
                        }
                        else
                        {
                            var kPtr = Items[prevOIdx];
                            kPtr.NextInStack = nextOIdx;
                        }
                        oPtr.NextInStack = 0;
                        break;
                    }
                    prevOIdx = thisOIdx;
                }
            }
            else
            {
                var y = jPtr.Y;
                var x = jPtr.X;
                var cPtr = Grid[y][x];
                for (thisOIdx = cPtr.Item; thisOIdx != 0; thisOIdx = nextOIdx)
                {
                    var oPtr = Items[thisOIdx];
                    nextOIdx = oPtr.NextInStack;
                    if (thisOIdx == oIdx)
                    {
                        if (prevOIdx == 0)
                        {
                            cPtr.Item = nextOIdx;
                        }
                        else
                        {
                            var kPtr = Items[prevOIdx];
                            kPtr.NextInStack = nextOIdx;
                        }
                        oPtr.NextInStack = 0;
                        break;
                    }
                    prevOIdx = thisOIdx;
                }
            }
        }

        public void FloorItemCharges(int item)
        {
            var oPtr = Items[item];
            if (oPtr.Category != ItemCategory.Staff && oPtr.Category != ItemCategory.Wand)
            {
                return;
            }
            if (!oPtr.IsKnown())
            {
                return;
            }
            Profile.Instance.MsgPrint(oPtr.TypeSpecificValue != 1
                ? $"There are {oPtr.TypeSpecificValue} charges remaining."
                : $"There is {oPtr.TypeSpecificValue} charge remaining.");
        }

        public void FloorItemDescribe(int item)
        {
            var oPtr = Items[item];
            var oName = oPtr.Description(true, 3);
            Profile.Instance.MsgPrint($"You see {oName}.");
        }

        public void FloorItemIncrease(int item, int num)
        {
            var oPtr = Items[item];
            num += oPtr.Count;
            if (num > 255)
            {
                num = 255;
            }
            else if (num < 0)
            {
                num = 0;
            }
            num -= oPtr.Count;
            oPtr.Count += num;
        }

        public void FloorItemOptimize(int item)
        {
            var oPtr = Items[item];
            if (oPtr.ItemType == null)
            {
                return;
            }
            if (oPtr.Count != 0)
            {
                return;
            }
            DeleteObjectIdx(item);
        }

        public void ForgetLight()
        {
            if (_lightN == 0)
            {
                return;
            }
            for (var i = 0; i < _lightN; i++)
            {
                var y = _lightY[i];
                var x = _lightX[i];
                Grid[y][x].TileFlags.Clear(GridTile.PlayerLit);
                LightSpot(y, x);
            }
            _lightN = 0;
        }

        public void ForgetView()
        {
            if (_viewN == 0)
            {
                return;
            }
            for (var i = 0; i < _viewN; i++)
            {
                var y = _viewY[i];
                var x = _viewX[i];
                var cPtr = Grid[y][x];
                cPtr.TileFlags.Clear(GridTile.IsVisible);
                LightSpot(y, x);
            }
            _viewN = 0;
        }

        private void ImageMonster(out int ap, out char cp)
        {
            cp = Profile.Instance.MonsterRaces[Program.Rng.DieRoll(Profile.Instance.MonsterRaces.Count - 2)].DChar;
            ap = Profile.Instance.MonsterRaces[Program.Rng.DieRoll(Profile.Instance.MonsterRaces.Count - 2)].DAttr;
        }

        private void ImageObject(out int ap, out char cp)
        {
            cp = Profile.Instance.ItemTypes[Program.Rng.DieRoll(Profile.Instance.ItemTypes.Count - 1)].XChar;
            ap = Profile.Instance.ItemTypes[Program.Rng.DieRoll(Profile.Instance.ItemTypes.Count - 1)].XAttr;
        }

        private void ImageRandom(out int ap, out char cp)
        {
            if (Program.Rng.RandomLessThan(100) < 75)
            {
                ImageMonster(out ap, out cp);
            }
            else
            {
                ImageObject(out ap, out cp);
            }
        }

        public bool InBounds(int y, int x)
        {
            return y > 0 && x > 0 && y < CurHgt - 1 && x < CurWid - 1;
        }

        public bool InBounds2(int y, int x)
        {
            return y >= 0 && x >= 0 && y < CurHgt && x < CurWid;
        }

        public void LightSpot(int y, int x)
        {
            MapInfoGraphic(y, x);
        }

        public bool Los(int y1, int x1, int y2, int x2)
        {
            int tx, ty;
            int m;
            var dy = y2 - y1;
            var dx = x2 - x1;
            var ay = Math.Abs(dy);
            var ax = Math.Abs(dx);
            if (ax < 2 && ay < 2)
            {
                return true;
            }
            if (dx == 0)
            {
                if (dy > 0)
                {
                    for (ty = y1 + 1; ty < y2; ty++)
                    {
                        if (GridBlocksLos(ty, x1))
                        {
                            return false;
                        }
                    }
                }
                else
                {
                    for (ty = y1 - 1; ty > y2; ty--)
                    {
                        if (GridBlocksLos(ty, x1))
                        {
                            return false;
                        }
                    }
                }
                return true;
            }
            if (dy == 0)
            {
                if (dx > 0)
                {
                    for (tx = x1 + 1; tx < x2; tx++)
                    {
                        if (GridBlocksLos(y1, tx))
                        {
                            return false;
                        }
                    }
                }
                else
                {
                    for (tx = x1 - 1; tx > x2; tx--)
                    {
                        if (GridBlocksLos(y1, tx))
                        {
                            return false;
                        }
                    }
                }
                return true;
            }
            var sx = dx < 0 ? -1 : 1;
            var sy = dy < 0 ? -1 : 1;
            if (ax == 1)
            {
                if (ay == 2)
                {
                    if (!GridBlocksLos(y1 + sy, x1))
                    {
                        return true;
                    }
                }
            }
            else if (ay == 1)
            {
                if (ax == 2)
                {
                    if (!GridBlocksLos(y1, x1 + sx))
                    {
                        return true;
                    }
                }
            }
            var f2 = ax * ay;
            var f1 = f2 << 1;
            if (ax >= ay)
            {
                var qy = ay * ay;
                m = qy << 1;
                tx = x1 + sx;
                if (qy == f2)
                {
                    ty = y1 + sy;
                    qy -= f1;
                }
                else
                {
                    ty = y1;
                }
                while (x2 - tx != 0)
                {
                    if (GridBlocksLos(ty, tx))
                    {
                        return false;
                    }
                    qy += m;
                    if (qy < f2)
                    {
                        tx += sx;
                    }
                    else if (qy > f2)
                    {
                        ty += sy;
                        if (GridBlocksLos(ty, tx))
                        {
                            return false;
                        }
                        qy -= f1;
                        tx += sx;
                    }
                    else
                    {
                        ty += sy;
                        qy -= f1;
                        tx += sx;
                    }
                }
            }
            else
            {
                var qx = ax * ax;
                m = qx << 1;
                ty = y1 + sy;
                if (qx == f2)
                {
                    tx = x1 + sx;
                    qx -= f1;
                }
                else
                {
                    tx = x1;
                }
                while (y2 - ty != 0)
                {
                    if (GridBlocksLos(ty, tx))
                    {
                        return false;
                    }
                    qx += m;
                    if (qx < f2)
                    {
                        ty += sy;
                    }
                    else if (qx > f2)
                    {
                        tx += sx;
                        if (GridBlocksLos(ty, tx))
                        {
                            return false;
                        }
                        qx -= f1;
                        ty += sy;
                    }
                    else
                    {
                        tx += sx;
                        qx -= f1;
                        ty += sy;
                    }
                }
            }
            return true;
        }

        public void MapArea()
        {
            var y1 = PanelRowMin - Program.Rng.DieRoll(10);
            var y2 = PanelRowMax + Program.Rng.DieRoll(10);
            var x1 = PanelColMin - Program.Rng.DieRoll(20);
            var x2 = PanelColMax + Program.Rng.DieRoll(20);
            if (y1 < 1)
            {
                y1 = 1;
            }
            if (y2 > CurHgt - 2)
            {
                y2 = CurHgt - 2;
            }
            if (x1 < 1)
            {
                x1 = 1;
            }
            if (x2 > CurWid - 2)
            {
                x2 = CurWid - 2;
            }
            for (var y = y1; y <= y2; y++)
            {
                for (var x = x1; x <= x2; x++)
                {
                    var cPtr = Grid[y][x];
                    if (cPtr.FeatureType.IsWall == false)
                    {
                        if (cPtr.FeatureType.IsOpenFloor == false)
                        {
                            cPtr.TileFlags.Set(GridTile.PlayerMemorised);
                        }
                        for (var i = 0; i < 8; i++)
                        {
                            cPtr = Grid[y + DdyDdd[i]][x + DdxDdd[i]];
                            if (cPtr.FeatureType.IsWall)
                            {
                                cPtr.TileFlags.Set(GridTile.PlayerMemorised);
                            }
                        }
                    }
                }
            }
            _player.Redraw |= RedrawFlag.PrMap;
        }

        private void MapInfo(int y, int x, out int ap, out char cp)
        {
            int nextOIdx;
            int a;
            char c;
            var cPtr = Grid[y][x];
            var feat = cPtr.FeatureType;
            if (feat.IsOpenFloor)
            {
                if (cPtr.TileFlags.IsSet(GridTile.PlayerMemorised) ||
                    (cPtr.TileFlags.IsSet(GridTile.PlayerLit) || cPtr.TileFlags.IsSet(GridTile.SelfLit) &&
                     cPtr.TileFlags.IsSet(GridTile.IsVisible)) && _player.Blind == 0)
                {
                    c = feat.Char;
                    a = feat.Attr;
                    if (a == Colour.White)
                    {
                        if (_player.Blind != 0)
                        {
                            a = Colour.Black;
                        }
                        else if (cPtr.TileFlags.IsSet(GridTile.PlayerLit))
                        {
                            a = Colour.Yellow;
                        }
                        else if (cPtr.TileFlags.IsClear(GridTile.SelfLit))
                        {
                            a = Colour.Black;
                        }
                        else if (cPtr.TileFlags.IsClear(GridTile.IsVisible))
                        {
                            a = Colour.Grey;
                        }
                        if (cPtr.TileFlags.IsSet(GridTile.TrapsDetected))
                        {
                            var count = 0;
                            if (Grid[y - 1][x].TileFlags.IsSet(GridTile.TrapsDetected))
                            {
                                count++;
                            }
                            if (Grid[y + 1][x].TileFlags.IsSet(GridTile.TrapsDetected))
                            {
                                count++;
                            }
                            if (Grid[y][x - 1].TileFlags.IsSet(GridTile.TrapsDetected))
                            {
                                count++;
                            }
                            if (Grid[y][x + 1].TileFlags.IsSet(GridTile.TrapsDetected))
                            {
                                count++;
                            }
                            if (count != 4)
                            {
                                a = Colour.BrightGreen;
                            }
                        }
                    }
                }
                else
                {
                    a = StaticResources.Instance.FloorTileTypes["Nothing"].Attr;
                    c = StaticResources.Instance.FloorTileTypes["Nothing"].Char;
                }
            }
            else
            {
                if (cPtr.TileFlags.IsSet(GridTile.PlayerMemorised))
                {
                    feat = string.IsNullOrEmpty(feat.AppearAs)
                        ? StaticResources.Instance.FloorTileTypes[cPtr.BackgroundFeature.AppearAs]
                        : StaticResources.Instance.FloorTileTypes[feat.AppearAs];
                    c = feat.Char;
                    a = feat.Attr;
                    if (a == Colour.White)
                    {
                        if (_player.Blind != 0)
                        {
                            a = Colour.Black;
                        }
                        else if (cPtr.TileFlags.IsSet(GridTile.PlayerLit))
                        {
                            a = Colour.Yellow;
                        }
                        else
                        {
                            if (cPtr.TileFlags.IsClear(GridTile.IsVisible))
                            {
                                a = Colour.Grey;
                            }
                            else if (cPtr.TileFlags.IsClear(GridTile.SelfLit))
                            {
                                a = Colour.Grey;
                            }
                            else
                            {
                                var yy = y < _player.Py ? y + 1 : y > _player.Py ? y - 1 : y;
                                var xx = x < _player.Px ? x + 1 : x > _player.Px ? x - 1 : x;
                                if (Grid[yy][xx].TileFlags.IsClear(GridTile.SelfLit))
                                {
                                    a = Colour.Grey;
                                }
                            }
                        }
                    }
                }
                else
                {
                    a = StaticResources.Instance.FloorTileTypes["Nothing"].Attr;
                    c = StaticResources.Instance.FloorTileTypes["Nothing"].Char;
                }
            }
            if (_player.Image != 0 && Program.Rng.RandomLessThan(256) == 0 && (cPtr.FeatureType.IsWall == false))
            {
                ImageRandom(out ap, out cp);
            }
            ap = a;
            cp = c;
            for (var thisOIdx = cPtr.Item; thisOIdx != 0; thisOIdx = nextOIdx)
            {
                var oPtr = Items[thisOIdx];
                nextOIdx = oPtr.NextInStack;
                if (oPtr.Marked)
                {
                    cp = oPtr.DisplayCharacter();
                    ap = oPtr.DisplayAttr();
                    if (_player.Image != 0)
                    {
                        ImageObject(out ap, out cp);
                    }
                    break;
                }
            }
            if (cPtr.Monster != 0)
            {
                var mPtr = Monsters[cPtr.Monster];
                if (mPtr.Ml)
                {
                    var rPtr = mPtr.Race;
                    a = rPtr.DAttr;
                    c = rPtr.DChar;
                    if ((a & 0x80) != 0 && (c & 0x80) != 0)
                    {
                        cp = c;
                        ap = a;
                    }
                    else if ((rPtr.Flags1 & MonsterFlag1.AttrMulti) != 0)
                    {
                        if ((rPtr.Flags2 & MonsterFlag2.Shapechanger) != 0)
                        {
                            cp = Program.Rng.DieRoll(25) == 1
                                ? ImageObjectHack[Program.Rng.RandomLessThan(ImageObjectHack.Length)]
                                : ImageMonsterHack[Program.Rng.RandomLessThan(ImageMonsterHack.Length)];
                        }
                        else
                        {
                            cp = c;
                        }
                        if ((rPtr.Flags2 & MonsterFlag2.AttrAny) != 0)
                        {
                            ap = Program.Rng.DieRoll(15);
                        }
                        else
                        {
                            switch (Program.Rng.DieRoll(7))
                            {
                                case 1:
                                    ap = Colour.Red;
                                    break;
                                case 2:
                                    ap = Colour.BrightRed;
                                    break;
                                case 3:
                                    ap = Colour.White;
                                    break;
                                case 4:
                                    ap = Colour.BrightGreen;
                                    break;
                                case 5:
                                    ap = Colour.Blue;
                                    break;
                                case 6:
                                    ap = Colour.Black;
                                    break;
                                case 7:
                                    ap = Colour.Green;
                                    break;
                            }
                        }
                    }
                    else if ((rPtr.Flags1 & (MonsterFlag1.AttrClear | MonsterFlag1.CharClear)) == 0)
                    {
                        cp = c;
                        ap = a;
                    }
                    else if ((ap & 0x80) != 0 || (cp & 0x80) != 0)
                    {
                        cp = c;
                        ap = a;
                    }
                    else
                    {
                        if ((rPtr.Flags1 & MonsterFlag1.CharClear) == 0)
                        {
                            cp = c;
                        }
                        else if ((rPtr.Flags1 & MonsterFlag1.AttrClear) == 0)
                        {
                            ap = a;
                        }
                    }
                    if (_player.Image != 0)
                    {
                        ImageMonster(out ap, out cp);
                    }
                }
            }
            if (y == _player.Py && x == _player.Px)
            {
                var rPtr = Profile.Instance.MonsterRaces[0];
                a = rPtr.DAttr;
                c = rPtr.DChar;
                ap = a;
                cp = c;
            }
        }

        private void MapInfoGraphic(int y, int x)
        {
            var tileX = x - _player.Px + 19;
            var tileY = y - _player.Py + 11;
            if (tileX < 0 || tileX > 38 || tileY < 0 || tileY > 22)
            {
                return;
            }
            if (!InBounds2(y, x))
            {
                Gui.GroundLayer.SetTile(tileY,tileX, -1, -1, Color.Transparent);
                Gui.FeatureLayer.SetTile(tileY, tileX, -1, -1, Color.Transparent);
                Gui.ItemLayer.SetTile(tileY, tileX, -1, -1, Color.Transparent);
                Gui.CreatureLayer.SetTile(tileY, tileX, -1, -1, Color.Transparent);
                Gui.SfxLayer.SetTile(tileY, tileX, -1, -1, Color.Transparent);
                return;
            }
            var tile = Grid[y][x];
            if (tile.TileFlags.IsSet(GridTile.PlayerMemorised))
            {
                var a = Color.Gainsboro;
                if (tile.TileFlags.IsSet(GridTile.TrapsDetected) && tile.FeatureType.IsPassable)
                {
                    var count = 0;
                    if (Grid[y - 1][x].TileFlags.IsSet(GridTile.TrapsDetected))
                    {
                        count++;
                    }
                    if (Grid[y + 1][x].TileFlags.IsSet(GridTile.TrapsDetected))
                    {
                        count++;
                    }
                    if (Grid[y][x - 1].TileFlags.IsSet(GridTile.TrapsDetected))
                    {
                        count++;
                    }
                    if (Grid[y][x + 1].TileFlags.IsSet(GridTile.TrapsDetected))
                    {
                        count++;
                    }
                    if (count != 4)
                    {
                        a = Color.Yellow;
                    }
                }
                if (_player.Blind != 0)
                {
                    a = Color.DarkSlateGray;
                }
                else if (tile.TileFlags.IsSet(GridTile.PlayerLit))
                {
                    if (a != Color.Yellow)
                    {
                        a = Color.White;
                    }
                }
                else
                {
                    if (tile.TileFlags.IsClear(GridTile.IsVisible))
                    {
                        a = Color.DarkSlateGray;
                    }
                    else if (tile.TileFlags.IsClear(GridTile.SelfLit))
                    {
                        a = Color.LightSlateGray;
                    }
                    else
                    {
                        var yy = y < _player.Py ? y + 1 : y > _player.Py ? y - 1 : y;
                        var xx = x < _player.Px ? x + 1 : x > _player.Px ? x - 1 : x;
                        if (Grid[yy][xx].TileFlags.IsClear(GridTile.SelfLit))
                        {
                            a = Color.Gainsboro;
                        }
                    }
                }
                var feat = tile.FeatureType;
                if (feat.IsFeature)
                {
                    var feat2 = tile.BackgroundFeature;
                    Gui.GroundLayer.SetTile(tileY, tileX, feat2.GraphicsRow, feat2.GraphicsCol, a);
                }
                else
                {
                    Gui.GroundLayer.SetTile(tileY, tileX, -1, -1, a);
                }
                Gui.FeatureLayer.SetTile(tileY, tileX, feat.GraphicsRow, feat.GraphicsCol, a);
            }
            else
            {
                Gui.FeatureLayer.SetTile(tileY, tileX, -1, -1, Color.Transparent);
                Gui.GroundLayer.SetTile(tileY, tileX, -1, -1, Color.Transparent);
            }
            int nextOIdx;
            Gui.ItemLayer.SetTile(tileY, tileX, -1, -1, Color.White);
            for (var thisOIdx = tile.Item; thisOIdx != 0; thisOIdx = nextOIdx)
            {
                var oPtr = Items[thisOIdx];
                nextOIdx = oPtr.NextInStack;
                if (oPtr.Marked)
                {
                    var itemType = oPtr.ItemType;
                    if (_player.Image != 0)
                    {
                        itemType = Profile.Instance.ItemTypes[
                            Program.Rng.RandomLessThan(Profile.Instance.ItemTypes.Count)];
                    }
                    Gui.ItemLayer.SetTile(tileY, tileX, itemType.GraphicsRow, itemType.GraphicsCol, Color.White);
                    break;
                }
            }
            if (x == _player.Px && y == _player.Py)
            {
                Gui.CreatureLayer.SetTile(tileY, tileX, 51, 11, Color.White);
            }
            else
            {
                Gui.CreatureLayer.SetTile(tileY, tileX, -1, -1, Color.White);
                if (tile.Monster != 0)
                {
                    var mPtr = Monsters[tile.Monster];
                    if (mPtr.Ml)
                    {
                        var race = mPtr.Race;
                        if (_player.Image > 0)
                        {
                            race = Profile.Instance.MonsterRaces[
                                Program.Rng.RandomLessThan(Profile.Instance.MonsterRaces.Count)];
                        }
                        if ((race.Flags1 & MonsterFlag1.AttrClear) != 0)
                        {
                            Gui.CreatureLayer.SetTile(tileY, tileX, race.GraphicsRow, race.GraphicsCol, Color.FromArgb(50,255,255,255));
                        }
                        else
                        {
                            Gui.CreatureLayer.SetTile(tileY, tileX, race.GraphicsRow, race.GraphicsCol, Color.White);
                        }
                    }
                }
            }
        }

        public void SetSfx(int y, int x, int graphicsRow, int graphicsCol)
        {
            var tileX = x - _player.Px + 19;
            var tileY = y - _player.Py + 11;
            if (tileX < 0 || tileX > 38 || tileY < 0 || tileY > 22)
            {
                return;
            }
            Gui.SfxLayer.SetTile(tileY, tileX, graphicsRow, graphicsCol, Color.Transparent);
        }

        public void Mmove2(out int y, out int x, int curY, int curX, int y1, int x1, int y2, int x2)
        {
            y = curY;
            x = curX;
            int shift;
            var dy = y < y1 ? y1 - y : y - y1;
            var dx = x < x1 ? x1 - x : x - x1;
            var dist = dy > dx ? dy : dx;
            dist++;
            dy = y2 < y1 ? y1 - y2 : y2 - y1;
            dx = x2 < x1 ? x1 - x2 : x2 - x1;
            if (dy == 0 && dx == 0)
            {
                return;
            }
            if (dy > dx)
            {
                shift = (dist * dx + (dy - 1) / 2) / dy;
                x = x2 < x1 ? x1 - shift : x1 + shift;
                y = y2 < y1 ? y1 - dist : y1 + dist;
            }
            else
            {
                shift = (dist * dy + (dx - 1) / 2) / dx;
                y = y2 < y1 ? y1 - shift : y1 + shift;
                x = x2 < x1 ? x1 - dist : x1 + dist;
            }
        }

        public void MoveCursorRelative(int row, int col)
        {
            row -= PanelRowPrt;
            col -= PanelColPrt;
            Gui.Goto(row, col);
        }

        public bool NoLight()
        {
            return !PlayerCanSeeBold(_player.Py, _player.Px);
        }

        public void NoteSpot(int y, int x)
        {
            var cPtr = Grid[y][x];
            int nextOIdx;
            if (_player.Blind != 0)
            {
                return;
            }
            if (cPtr.TileFlags.IsClear(GridTile.PlayerLit))
            {
                if (cPtr.TileFlags.IsClear(GridTile.IsVisible))
                {
                    return;
                }
                if (cPtr.TileFlags.IsClear(GridTile.SelfLit))
                {
                    return;
                }
            }
            for (var thisOIdx = cPtr.Item; thisOIdx != 0; thisOIdx = nextOIdx)
            {
                var oPtr = Items[thisOIdx];
                nextOIdx = oPtr.NextInStack;
                oPtr.Marked = true;
            }
            if (cPtr.TileFlags.IsClear(GridTile.PlayerMemorised))
            {
                if (cPtr.FeatureType.IsOpenFloor)
                {
                    cPtr.TileFlags.Set(GridTile.PlayerMemorised);
                }
                else if (cPtr.FeatureType.IsPassable)
                {
                    cPtr.TileFlags.Set(GridTile.PlayerMemorised);
                }
                else if (cPtr.TileFlags.IsSet(GridTile.PlayerLit))
                {
                    cPtr.TileFlags.Set(GridTile.PlayerMemorised);
                }
                else
                {
                    var yy = y < _player.Py ? y + 1 : y > _player.Py ? y - 1 : y;
                    var xx = x < _player.Px ? x + 1 : x > _player.Px ? x - 1 : x;
                    if (Grid[yy][xx].TileFlags.IsSet(GridTile.SelfLit))
                    {
                        cPtr.TileFlags.Set(GridTile.PlayerMemorised);
                    }
                }
            }
        }

        public int OPop()
        {
            int i;
            if (OMax < Constants.MaxOIdx)
            {
                i = OMax;
                OMax++;
                OCnt++;
                return i;
            }
            for (i = 1; i < OMax; i++)
            {
                var oPtr = Items[i];
                if (oPtr.ItemType != null)
                {
                    continue;
                }
                OCnt++;
                return i;
            }
            return 0;
        }

        public bool PanelContains(int y, int x)
        {
            return y >= PanelRowMin && y <= PanelRowMax && x >= PanelColMin && x <= PanelColMax;
        }

        public void PickTrap(int y, int x)
        {
            string feat;
            var cPtr = Grid[y][x];
            if (cPtr.FeatureType.Name != "Invis")
            {
                return;
            }
            var trapType = Program.Rng.DieRoll(16);
            if (SaveGame.Instance.Quests.IsQuest(SaveGame.Instance.DunLevel))
            {
                trapType = Program.Rng.DieRoll(15);
            }
            if (SaveGame.Instance.DunLevel >= SaveGame.Instance.CurDungeon.MaxLevel)
            {
                trapType = Program.Rng.DieRoll(15);
            }
            switch (trapType)
            {
                case 1:
                    feat = "AcidTrap";
                    break;
                case 2:
                    feat = "FireTrap";
                    break;
                case 3:
                    feat = "StrDart";
                    break;
                case 4:
                    feat = "ConDart";
                    break;
                case 5:
                    feat = "DexDart";
                    break;
                case 6:
                    feat = "SlowDart";
                    break;
                case 7:
                    feat = "PoisonGas";
                    break;
                case 8:
                    feat = "ConfuseGas";
                    break;
                case 9:
                    feat = "SleepGas";
                    break;
                case 10:
                    feat = "BlindGas";
                    break;
                case 11:
                    feat = "SummonRune";
                    break;
                case 12:
                    feat = "TeleportRune";
                    break;
                case 13:
                    feat = "Pit";
                    break;
                case 14:
                    feat = "SpikedPit";
                    break;
                case 15:
                    feat = "PoisonPit";
                    break;
                default:
                    feat = "TrapDoor";
                    break;
            }
            CaveSetFeat(y, x, feat);
        }

        public void PlaceGold(int y, int x)
        {
            if (!InBounds(y, x))
            {
                return;
            }
            if (!GridOpenNoItem(y, x))
            {
                return;
            }
            var qPtr = new Item();
            if (!qPtr.MakeGold())
            {
                return;
            }
            var oIdx = OPop();
            if (oIdx != 0)
            {
                Items[oIdx] = new Item(qPtr);
                var oPtr = Items[oIdx];
                oPtr.Y = y;
                oPtr.X = x;
                var cPtr = Grid[y][x];
                oPtr.NextInStack = cPtr.Item;
                cPtr.Item = oIdx;
                NoteSpot(y, x);
                LightSpot(y, x);
            }
        }

        public void PlaceObject(int y, int x, bool good, bool great)
        {
            if (!InBounds(y, x))
            {
                return;
            }
            if (!GridOpenNoItem(y, x))
            {
                return;
            }
            var qPtr = new Item();
            if (!qPtr.MakeObject(good, great))
            {
                return;
            }
            var oIdx = OPop();
            if (oIdx != 0)
            {
                Items[oIdx] = new Item(qPtr);
                var oPtr = Items[oIdx];
                oPtr.Y = y;
                oPtr.X = x;
                var cPtr = Grid[y][x];
                oPtr.NextInStack = cPtr.Item;
                cPtr.Item = oIdx;
                NoteSpot(y, x);
                LightSpot(y, x);
            }
            else
            {
                if (qPtr.FixedArtifactIndex != 0)
                {
                    Profile.Instance.FixedArtifacts[qPtr.FixedArtifactIndex].CurNum = 0;
                }
            }
        }

        public void PlaceTrap(int y, int x)
        {
            if (!InBounds(y, x))
            {
                return;
            }
            if (!GridOpenNoItemOrCreature(y, x))
            {
                return;
            }
            CaveSetFeat(y, x, "Invis");
        }

        public bool PlayerCanSeeBold(int y, int x)
        {
            if (_player.Blind != 0)
            {
                return false;
            }
            var cPtr = Grid[y][x];
            if (cPtr.TileFlags.IsSet(GridTile.PlayerLit))
            {
                return true;
            }
            if (!PlayerHasLosBold(y, x))
            {
                return false;
            }
            if (cPtr.TileFlags.IsClear(GridTile.SelfLit))
            {
                return false;
            }
            if (GridPassable(y, x))
            {
                return true;
            }
            var yy = y < _player.Py ? y + 1 : y > _player.Py ? y - 1 : y;
            var xx = x < _player.Px ? x + 1 : x > _player.Px ? x - 1 : x;
            if (Grid[yy][xx].TileFlags.IsSet(GridTile.SelfLit))
            {
                return true;
            }
            return false;
        }

        public bool PlayerHasLosBold(int y, int x)
        {
            return Grid[y][x].TileFlags.IsSet(GridTile.IsVisible);
        }

        public void PrintRel(char c, int a, int y, int x)
        {
            if (PanelContains(y, x))
            {
                if (_player.Invuln != 0)
                {
                    a = Colour.White;
                }
                else if (_player.WraithForm != 0)
                {
                    a = Colour.Black;
                }
                Gui.Place(a, c, y - PanelRowPrt, x - PanelColPrt);
            }
        }

        private int Priority(int a, char c)
        {
            for (var i = 0;; i++)
            {
                var p1 = _priorityTable[i][1];
                if (p1 == 0)
                {
                    break;
                }
                var p0 = _priorityTable[i][0];
                var fPtr = Profile.Instance.TileFeatures[p0];
                if (fPtr.Char == c && fPtr.Attr == a)
                {
                    return p1;
                }
            }
            return 20;
        }

        public bool Projectable(int y1, int x1, int y2, int x2)
        {
            var y = y1;
            var x = x1;
            for (var dist = 0; dist <= Constants.MaxRange; dist++)
            {
                if (x == x2 && y == y2)
                {
                    return true;
                }
                if (dist != 0 && !GridPassable(y, x) && Grid[y][x].FeatureType.Name !="ExplosiveRune")
                {
                    break;
                }
                Mmove2(out y, out x, y, x, y1, x1, y2, x2);
            }
            return false;
        }

        public void PrtMapGraphic()
        {
            for (int dy = -11; dy <= 11; dy++)
            {
                for (int dx = -19; dx <= 19; dx++)
                {
                    var x = _player.Px + dx;
                    var y = _player.Py + dy;
                    MapInfoGraphic(y, x);
                }
            }
        }

        public void PutQuestMonster(int rIdx)
        {
            int y, x;
            if (Profile.Instance.MonsterRaces[rIdx].MaxNum == 0)
            {
                Profile.Instance.MonsterRaces[rIdx].MaxNum++;
                Profile.Instance.MsgPrint("Resurrecting guardian to fix corrupted savefile...");
            }
            do
            {
                while (true)
                {
                    y = Program.Rng.RandomLessThan(MaxHgt);
                    x = Program.Rng.RandomLessThan(MaxWid);
                    if (!GridOpenNoItemOrCreature(y, x))
                    {
                        continue;
                    }
                    {
                        if (Distance(y, x, SaveGame.Instance.Player.Py, SaveGame.Instance.Player.Px) > 15)
                        {
                            break;
                        }
                    }
                }
            } while (!Monsters.PlaceMonsterByIndex(y, x, rIdx, false, false, false));
        }

        public void ReplacePets(int y, int x, List<Monster> petList)
        {
            foreach (var monster in petList)
            {
                Monsters.ReplacePet(y, x, monster);
            }
        }

        public void ReplaceSecretDoor(int y, int x)
        {
            var tmp = Program.Rng.RandomLessThan(400);
            if (tmp < 300)
            {
                CaveSetFeat(y, x, "LockedDoor0");
            }
            else if (tmp < 999)
            {
                CaveSetFeat(y, x, $"LockedDoor{Program.Rng.DieRoll(7)}");
            }
            else
            {
                CaveSetFeat(y, x, $"JammedDoor{Program.Rng.RandomLessThan(8)}");
            }
        }

        public void Scatter(out int yp, out int xp, int y, int x, int d)
        {
            var nx = 0;
            var ny = 0;
            yp = y;
            xp = x;
            var attemptsLeft = 5000;
            while (--attemptsLeft != 0)
            {
                ny = Program.Rng.RandomSpread(y, d);
                nx = Program.Rng.RandomSpread(x, d);
                if (!InBounds(y, x))
                {
                    continue;
                }
                if (d > 1 && Distance(y, x, ny, nx) > d)
                {
                    continue;
                }
                if (Los(y, x, ny, nx))
                {
                    break;
                }
            }
            if (attemptsLeft > 0)
            {
                yp = ny;
                xp = nx;
            }
        }

        public void UpdateFlow()
        {
            int x, y;
            if (TempN != 0)
            {
                return;
            }
            if (_flowN == 255)
            {
                for (y = 0; y < CurHgt; y++)
                {
                    for (x = 0; x < CurWid; x++)
                    {
                        var w = Grid[y][x].FlowAge;
                        Grid[y][x].FlowAge = w > 128 ? w - 128 : 0;
                    }
                }
                _flowN = 127;
            }
            _flowN++;
            _flowHead = 0;
            _flowTail = 0;
            UpdateFlowAux(_player.Py, _player.Px, 0);
            while (_flowHead != _flowTail)
            {
                y = TempY[_flowTail];
                x = TempX[_flowTail];
                if (++_flowTail == Constants.TempMax)
                {
                    _flowTail = 0;
                }
                for (var d = 0; d < 8; d++)
                {
                    UpdateFlowAux(y + DdyDdd[d], x + DdxDdd[d], Grid[y][x].FlowCost + 1);
                }
            }
            _flowHead = _flowTail = 0;
        }

        private void UpdateFlowAux(int y, int x, int n)
        {
            var oldHead = _flowHead;
            var cPtr = Grid[y][x];
            if (cPtr.FlowAge == _flowN)
            {
                return;
            }
            if (cPtr.FeatureType.BlocksLos && cPtr.FeatureType.Name != "SecretDoor")
            {
                return;
            }
            cPtr.FlowAge = _flowN;
            cPtr.FlowCost = n;
            if (n == Constants.MonsterFlowDepth)
            {
                return;
            }
            TempY[_flowHead] = y;
            TempX[_flowHead] = x;
            if (++_flowHead == Constants.TempMax)
            {
                _flowHead = 0;
            }
            if (_flowHead == _flowTail)
            {
                _flowHead = oldHead;
            }
        }

        public void UpdateLight()
        {
            int i, x, y;
            if (_player.LightLevel <= 0)
            {
                ForgetLight();
                LightSpot(_player.Py, _player.Px);
                return;
            }
            for (i = 0; i < _lightN; i++)
            {
                y = _lightY[i];
                x = _lightX[i];
                Grid[y][x].TileFlags.Clear(GridTile.PlayerLit);
                Grid[y][x].TileFlags.Set(GridTile.TempFlag);
                TempY[TempN] = y;
                TempX[TempN] = x;
                TempN++;
            }
            _lightN = 0;
            CaveLightHack(_player.Py, _player.Px);
            if (_player.LightLevel >= 1)
            {
                CaveLightHack(_player.Py + 1, _player.Px);
                CaveLightHack(_player.Py - 1, _player.Px);
                CaveLightHack(_player.Py, _player.Px + 1);
                CaveLightHack(_player.Py, _player.Px - 1);
                CaveLightHack(_player.Py + 1, _player.Px + 1);
                CaveLightHack(_player.Py + 1, _player.Px - 1);
                CaveLightHack(_player.Py - 1, _player.Px + 1);
                CaveLightHack(_player.Py - 1, _player.Px - 1);
            }
            if (_player.LightLevel >= 2)
            {
                if (GridPassable(_player.Py + 1, _player.Px))
                {
                    CaveLightHack(_player.Py + 2, _player.Px);
                    CaveLightHack(_player.Py + 2, _player.Px + 1);
                    CaveLightHack(_player.Py + 2, _player.Px - 1);
                }
                if (GridPassable(_player.Py - 1, _player.Px))
                {
                    CaveLightHack(_player.Py - 2, _player.Px);
                    CaveLightHack(_player.Py - 2, _player.Px + 1);
                    CaveLightHack(_player.Py - 2, _player.Px - 1);
                }
                if (GridPassable(_player.Py, _player.Px + 1))
                {
                    CaveLightHack(_player.Py, _player.Px + 2);
                    CaveLightHack(_player.Py + 1, _player.Px + 2);
                    CaveLightHack(_player.Py - 1, _player.Px + 2);
                }
                if (GridPassable(_player.Py, _player.Px - 1))
                {
                    CaveLightHack(_player.Py, _player.Px - 2);
                    CaveLightHack(_player.Py + 1, _player.Px - 2);
                    CaveLightHack(_player.Py - 1, _player.Px - 2);
                }
            }
            if (_player.LightLevel >= 3)
            {
                var p = _player.LightLevel;
                if (p > 5)
                {
                    p = 5;
                }
                if (GridPassable(_player.Py + 1, _player.Px + 1))
                {
                    CaveLightHack(_player.Py + 2, _player.Px + 2);
                }
                if (GridPassable(_player.Py + 1, _player.Px - 1))
                {
                    CaveLightHack(_player.Py + 2, _player.Px - 2);
                }
                if (GridPassable(_player.Py - 1, _player.Px + 1))
                {
                    CaveLightHack(_player.Py - 2, _player.Px + 2);
                }
                if (GridPassable(_player.Py - 1, _player.Px - 1))
                {
                    CaveLightHack(_player.Py - 2, _player.Px - 2);
                }
                var minY = _player.Py - p;
                if (minY < 0)
                {
                    minY = 0;
                }
                var maxY = _player.Py + p;
                if (maxY > CurHgt - 1)
                {
                    maxY = CurHgt - 1;
                }
                var minX = _player.Px - p;
                if (minX < 0)
                {
                    minX = 0;
                }
                var maxX = _player.Px + p;
                if (maxX > CurWid - 1)
                {
                    maxX = CurWid - 1;
                }
                for (y = minY; y <= maxY; y++)
                {
                    for (x = minX; x <= maxX; x++)
                    {
                        var dy = _player.Py > y ? _player.Py - y : y - _player.Py;
                        var dx = _player.Px > x ? _player.Px - x : x - _player.Px;
                        if (dy <= 2 && dx <= 2)
                        {
                            continue;
                        }
                        var d = dy > dx ? dy + (dx >> 1) : dx + (dy >> 1);
                        if (d > p)
                        {
                            continue;
                        }
                        if (PlayerHasLosBold(y, x))
                        {
                            CaveLightHack(y, x);
                        }
                    }
                }
            }
            for (i = 0; i < _lightN; i++)
            {
                y = _lightY[i];
                x = _lightX[i];
                if (Grid[y][x].TileFlags.IsSet(GridTile.TempFlag))
                {
                    continue;
                }
                NoteSpot(y, x);
                LightSpot(y, x);
            }
            for (i = 0; i < TempN; i++)
            {
                y = TempY[i];
                x = TempX[i];
                Grid[y][x].TileFlags.Clear(GridTile.TempFlag);
                if (Grid[y][x].TileFlags.IsSet(GridTile.PlayerLit))
                {
                    continue;
                }
                LightSpot(y, x);
            }
            TempN = 0;
        }

        public void UpdateMonsters(bool full)
        {
            for (var i = 1; i < MMax; i++)
            {
                var mPtr = Monsters[i];
                if (mPtr.Race == null)
                {
                    continue;
                }
                Monsters.UpdateMon(i, full);
            }
        }

        public void UpdateView()
        {
            int n;
            int d;
            int y, x;
            var yMax = CurHgt - 1;
            var xMax = CurWid - 1;
            GridTile cPtr;
            var full = Constants.MaxSight;
            var over = Constants.MaxSight * 3 / 2;
            for (n = 0; n < _viewN; n++)
            {
                y = _viewY[n];
                x = _viewX[n];
                cPtr = Grid[y][x];
                cPtr.TileFlags.Clear(GridTile.IsVisible);
                cPtr.TileFlags.Set(GridTile.TempFlag);
                TempY[TempN] = y;
                TempX[TempN] = x;
                TempN++;
            }
            _viewN = 0;
            y = _player.Py;
            x = _player.Px;
            cPtr = Grid[y][x];
            cPtr.TileFlags.Set(GridTile.EasyVisibility);
            CaveViewHack(cPtr, y, x);
            var z = full * 2 / 3;
            for (d = 1; d <= z; d++)
            {
                cPtr = Grid[y + d][x + d];
                cPtr.TileFlags.Set(GridTile.EasyVisibility);
                CaveViewHack(cPtr, y + d, x + d);
                if (cPtr.FeatureType.BlocksLos)
                {
                    break;
                }
                if (!InBounds2(y + d, x + d))
                {
                    break;
                }
            }
            for (d = 1; d <= z; d++)
            {
                cPtr = Grid[y + d][x - d];
                cPtr.TileFlags.Set(GridTile.EasyVisibility);
                CaveViewHack(cPtr, y + d, x - d);
                if (cPtr.FeatureType.BlocksLos)
                {
                    break;
                }
                if (!InBounds2(y + d, x - d))
                {
                    break;
                }
            }
            for (d = 1; d <= z; d++)
            {
                cPtr = Grid[y - d][x + d];
                cPtr.TileFlags.Set(GridTile.EasyVisibility);
                CaveViewHack(cPtr, y - d, x + d);
                if (cPtr.FeatureType.BlocksLos)
                {
                    break;
                }
                if (!InBounds2(y - d, x + d))
                {
                    break;
                }
            }
            for (d = 1; d <= z; d++)
            {
                cPtr = Grid[y - d][x - d];
                cPtr.TileFlags.Set(GridTile.EasyVisibility);
                CaveViewHack(cPtr, y - d, x - d);
                if (cPtr.FeatureType.BlocksLos)
                {
                    break;
                }
                if (!InBounds2(y - d, x - d))
                {
                    break;
                }
            }
            for (d = 1; d <= full; d++)
            {
                cPtr = Grid[y + d][x];
                cPtr.TileFlags.Set(GridTile.EasyVisibility);
                CaveViewHack(cPtr, y + d, x);
                if (cPtr.FeatureType.BlocksLos)
                {
                    break;
                }
                if (!InBounds2(y + d, x))
                {
                    break;
                }
            }
            var se = d;
            var sw = d;
            for (d = 1; d <= full; d++)
            {
                cPtr = Grid[y - d][x];
                cPtr.TileFlags.Set(GridTile.EasyVisibility);
                CaveViewHack(cPtr, y - d, x);
                if (cPtr.FeatureType.BlocksLos)
                {
                    break;
                }
                if (!InBounds2(y - d, x))
                {
                    break;
                }
            }
            var ne = d;
            var nw = d;
            for (d = 1; d <= full; d++)
            {
                cPtr = Grid[y][x + d];
                cPtr.TileFlags.Set(GridTile.EasyVisibility);
                CaveViewHack(cPtr, y, x + d);
                if (cPtr.FeatureType.BlocksLos)
                {
                    break;
                }
                if (!InBounds2(y, x + d))
                {
                    break;
                }
            }
            var es = d;
            var en = d;
            for (d = 1; d <= full; d++)
            {
                cPtr = Grid[y][x - d];
                cPtr.TileFlags.Set(GridTile.EasyVisibility);
                CaveViewHack(cPtr, y, x - d);
                if (cPtr.FeatureType.BlocksLos)
                {
                    break;
                }
                if (!InBounds2(y, x - d))
                {
                    break;
                }
            }
            var ws = d;
            var wn = d;
            for (n = 1; n <= over / 2; n++)
            {
                z = over - n - n;
                if (z > full - n)
                {
                    z = full - n;
                }
                while (z + n + (n >> 1) > full)
                {
                    z--;
                }
                var ypn = y + n;
                var ymn = y - n;
                var xpn = x + n;
                var xmn = x - n;
                int m;
                int k;
                if (ypn < yMax)
                {
                    m = Math.Min(z, yMax - ypn);
                    if (xpn <= xMax && n < se)
                    {
                        for (k = n, d = 1; d <= m; d++)
                        {
                            if (UpdateViewAux(ypn + d, xpn, ypn + d - 1, xpn - 1, ypn + d - 1, xpn))
                            {
                                if (n + d >= se)
                                {
                                    break;
                                }
                            }
                            else
                            {
                                k = n + d;
                            }
                        }
                        se = k + 1;
                    }
                    if (xmn >= 0 && n < sw)
                    {
                        for (k = n, d = 1; d <= m; d++)
                        {
                            if (UpdateViewAux(ypn + d, xmn, ypn + d - 1, xmn + 1, ypn + d - 1, xmn))
                            {
                                if (n + d >= sw)
                                {
                                    break;
                                }
                            }
                            else
                            {
                                k = n + d;
                            }
                        }
                        sw = k + 1;
                    }
                }
                if (ymn > 0)
                {
                    m = Math.Min(z, ymn);
                    if (xpn <= xMax && n < ne)
                    {
                        for (k = n, d = 1; d <= m; d++)
                        {
                            if (UpdateViewAux(ymn - d, xpn, ymn - d + 1, xpn - 1, ymn - d + 1, xpn))
                            {
                                if (n + d >= ne)
                                {
                                    break;
                                }
                            }
                            else
                            {
                                k = n + d;
                            }
                        }
                        ne = k + 1;
                    }
                    if (xmn >= 0 && n < nw)
                    {
                        for (k = n, d = 1; d <= m; d++)
                        {
                            if (UpdateViewAux(ymn - d, xmn, ymn - d + 1, xmn + 1, ymn - d + 1, xmn))
                            {
                                if (n + d >= nw)
                                {
                                    break;
                                }
                            }
                            else
                            {
                                k = n + d;
                            }
                        }
                        nw = k + 1;
                    }
                }
                if (xpn < xMax)
                {
                    m = Math.Min(z, xMax - xpn);
                    if (ypn <= xMax && n < es)
                    {
                        for (k = n, d = 1; d <= m; d++)
                        {
                            if (UpdateViewAux(ypn, xpn + d, ypn - 1, xpn + d - 1, ypn, xpn + d - 1))
                            {
                                if (n + d >= es)
                                {
                                    break;
                                }
                            }
                            else
                            {
                                k = n + d;
                            }
                        }
                        es = k + 1;
                    }
                    if (ymn >= 0 && n < en)
                    {
                        for (k = n, d = 1; d <= m; d++)
                        {
                            if (UpdateViewAux(ymn, xpn + d, ymn + 1, xpn + d - 1, ymn, xpn + d - 1))
                            {
                                if (n + d >= en)
                                {
                                    break;
                                }
                            }
                            else
                            {
                                k = n + d;
                            }
                        }
                        en = k + 1;
                    }
                }
                if (xmn > 0)
                {
                    m = Math.Min(z, xmn);
                    if (ypn <= yMax && n < ws)
                    {
                        for (k = n, d = 1; d <= m; d++)
                        {
                            if (UpdateViewAux(ypn, xmn - d, ypn - 1, xmn - d + 1, ypn, xmn - d + 1))
                            {
                                if (n + d >= ws)
                                {
                                    break;
                                }
                            }
                            else
                            {
                                k = n + d;
                            }
                        }
                        ws = k + 1;
                    }
                    if (ymn >= 0 && n < wn)
                    {
                        for (k = n, d = 1; d <= m; d++)
                        {
                            if (UpdateViewAux(ymn, xmn - d, ymn + 1, xmn - d + 1, ymn, xmn - d + 1))
                            {
                                if (n + d >= wn)
                                {
                                    break;
                                }
                            }
                            else
                            {
                                k = n + d;
                            }
                        }
                        wn = k + 1;
                    }
                }
            }
            for (n = 0; n < _viewN; n++)
            {
                y = _viewY[n];
                x = _viewX[n];
                cPtr = Grid[y][x];
                cPtr.TileFlags.Clear(GridTile.EasyVisibility);
                if (cPtr.TileFlags.IsSet(GridTile.TempFlag))
                {
                    continue;
                }
                NoteSpot(y, x);
                LightSpot(y, x);
            }
            for (n = 0; n < TempN; n++)
            {
                y = TempY[n];
                x = TempX[n];
                cPtr = Grid[y][x];
                cPtr.TileFlags.Clear(GridTile.TempFlag);
                if (cPtr.TileFlags.IsSet(GridTile.IsVisible))
                {
                    continue;
                }
                LightSpot(y, x);
            }
            TempN = 0;
        }

        private bool UpdateViewAux(int y, int x, int y1, int x1, int y2, int x2)
        {
            var g1CPtr = Grid[y1][x1];
            var g2CPtr = Grid[y2][x2];
            var f1 = !g1CPtr.FeatureType.BlocksLos;
            var f2 = !g2CPtr.FeatureType.BlocksLos;
            if (!f1 && !f2)
            {
                return true;
            }
            var v1 = f1 && g1CPtr.TileFlags.IsSet(GridTile.IsVisible);
            var v2 = f2 && g2CPtr.TileFlags.IsSet(GridTile.IsVisible);
            if (!v1 && !v2)
            {
                return true;
            }
            var cPtr = Grid[y][x];
            var wall = cPtr.FeatureType.BlocksLos;
            var z1 = v1 && g1CPtr.TileFlags.IsSet(GridTile.EasyVisibility);
            var z2 = v2 && g2CPtr.TileFlags.IsSet(GridTile.EasyVisibility);
            if (z1 && z2)
            {
                cPtr.TileFlags.Set(GridTile.EasyVisibility);
                CaveViewHack(cPtr, y, x);
                return wall;
            }
            if (z1)
            {
                CaveViewHack(cPtr, y, x);
                return wall;
            }
            if (v1 && v2)
            {
                CaveViewHack(cPtr, y, x);
                return wall;
            }
            if (wall)
            {
                CaveViewHack(cPtr, y, x);
                return true;
            }
            if (Los(_player.Py, _player.Px, y, x))
            {
                CaveViewHack(cPtr, y, x);
                return false;
            }
            return true;
        }

        public void WipeMList()
        {
            for (var i = MMax - 1; i >= 1; i--)
            {
                var mPtr = Monsters[i];
                var rPtr = mPtr.Race;
                if (mPtr.Race == null)
                {
                    continue;
                }
                rPtr.CurNum--;
                Grid[mPtr.Fy][mPtr.Fx].Monster = 0;
                Monsters[i] = new Monster();
            }
            MMax = 1;
            MCnt = 0;
            Monsters.NumRepro = 0;
            SaveGame.Instance.TargetWho = 0;
            SaveGame.Instance.HealthTrack(0);
        }

        public void WipeOList()
        {
            for (var i = 1; i < OMax; i++)
            {
                var oPtr = Items[i];
                if (oPtr.ItemType == null)
                {
                    continue;
                }
                if (oPtr.HoldingMonsterIndex != 0)
                {
                    var mPtr = Monsters[oPtr.HoldingMonsterIndex];
                    mPtr.HoldOIdx = 0;
                }
                else
                {
                    var y = oPtr.Y;
                    var x = oPtr.X;
                    var cPtr = Grid[y][x];
                    cPtr.Item = 0;
                }
                Items[i] = new Item();
            }
            OMax = 1;
            OCnt = 0;
        }

        public void WizDark()
        {
            for (var y = 0; y < CurHgt; y++)
            {
                for (var x = 0; x < CurWid; x++)
                {
                    var cPtr = Grid[y][x];
                    cPtr.TileFlags.Clear(GridTile.PlayerMemorised);
                }
            }
            for (var i = 1; i < OMax; i++)
            {
                var oPtr = Items[i];
                if (oPtr.ItemType == null)
                {
                    continue;
                }
                if (oPtr.HoldingMonsterIndex != 0)
                {
                    continue;
                }
                oPtr.Marked = false;
            }
            _player.Update |= Constants.PuUnView | Constants.PuUnLight;
            _player.Update |= Constants.PuView | Constants.PuLight;
            _player.Update |= Constants.PuMonsters;
            _player.Redraw |= RedrawFlag.PrMap;
        }

        public void WizLight()
        {
            int i;
            for (i = 1; i < OMax; i++)
            {
                var oPtr = Items[i];
                if (oPtr.ItemType != null)
                {
                    continue;
                }
                if (oPtr.HoldingMonsterIndex != 0)
                {
                    continue;
                }
                oPtr.Marked = true;
            }
            for (var y = 1; y < CurHgt - 1; y++)
            {
                for (var x = 1; x < CurWid - 1; x++)
                {
                    var cPtr = Grid[y][x];
                    if (cPtr.FeatureType.IsWall ==false)
                    {
                        for (i = 0; i < 9; i++)
                        {
                            var yy = y + DdyDdd[i];
                            var xx = x + DdxDdd[i];
                            cPtr = Grid[yy][xx];
                            cPtr.TileFlags.Set(GridTile.SelfLit);
                            if (cPtr.FeatureType.IsOpenFloor == false)
                            {
                                cPtr.TileFlags.Set(GridTile.PlayerMemorised);
                            }
                            cPtr.TileFlags.Set(GridTile.PlayerMemorised);
                        }
                    }
                }
            }
            _player.Update |= Constants.PuMonsters;
            _player.Redraw |= RedrawFlag.PrMap;
        }

    }
}